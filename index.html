<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026元旦特效 | 新年祝福</title>
    <style>
        * {margin: 0;padding: 0;box-sizing: border-box;}
        body {overflow: hidden;background: #000;height: 100vh;cursor: pointer;}
        canvas {position: fixed;top: 0;left: 0;width: 100%;height: 100%;z-index: 1;}
        
        .scene {position: fixed;top: 0;left: 0;width: 100%;height: 100%;opacity: 0;transition: opacity 1.8s ease-in-out;}
        .scene.active {opacity: 1;}
        
        .text-container {position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999;text-align: center;}
        .main-text {font-size: 8vw;font-weight: bold;background: linear-gradient(120deg,#ff0000,#ff9900,#ff0000,#ffcc00);-webkit-background-clip: text;color: transparent;text-shadow: 0 0 30px #ff0000,0 0 60px #ff9900;animation: textAni 3s linear infinite;}
        
        .blessing {position: fixed;z-index: 998;color: #fff;font-size: 22px;text-shadow:0 0 10px #ff0000;white-space: nowrap;pointer-events: none;}
        
        .control-panel {position: fixed;bottom: 20px;left: 50%;transform: translateX(-50%);z-index: 1000;background: rgba(0,0,0,0.7);padding: 15px;border-radius: 20px;display: flex;gap: 15px;}
        .control-btn {background: linear-gradient(135deg, #ff0066, #ff9900, #ff0066);color: white;border: none;padding: 10px 20px;border-radius: 10px;cursor: pointer;font-weight: bold;font-size: 15px;position: relative;overflow: hidden;transition: all 0.4s ease;box-shadow: 0 0 15px #ff0066;}
        .control-btn:hover {transform: scale(1.15);box-shadow: 0 0 25px #ff9900, 0 0 40px #ff0066;}
        .control-btn:active {transform: scale(1.05);}
        .control-btn::after {content: '';position: absolute;top: 0;left: -100%;width: 100%;height: 100%;background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);animation: lightAni 1.8s linear infinite;}
        
        .fireworks-count {position: fixed;top: 20px;right: 20px;color: white;font-size: 18px;z-index: 1000;background: rgba(0,0,0,0.5);padding: 10px;border-radius: 10px;}
        
        @keyframes textAni {0% {filter: hue-rotate(0deg);}100% {filter: hue-rotate(360deg);}}
        @keyframes float {0% {transform: translateY(0) rotate(0deg);opacity: 1;}100% {transform: translateY(-100vh) rotate(360deg);opacity: 0;}}
        @keyframes pulse {0%,100% {transform: scale(1);}50% {transform: scale(1.1);}}
        @keyframes lightAni {100% {left: 100%;}}
        @keyframes blossom {0% {transform: scale(0) rotate(0deg);opacity: 0;}100% {transform: scale(1) rotate(360deg);opacity: 0.8;}}
    </style>
</head>
<body>
    <div class="scene active" id="scene1">
        <div class="text-container">
            <div class="main-text">元旦快乐</div>
            <div style="color: #ffcc00;font-size: 4vw;margin-top: 30px;text-shadow: 0 0 20px #ffcc00;animation: pulse 2s infinite;">Happy New Year</div>
        </div>
    </div>
    
    <div class="scene" id="scene2">
        <div class="text-container">
            <div class="main-text" style="background: linear-gradient(120deg,#00ff88,#0088ff,#00ff88);-webkit-background-clip: text;">福满人间</div>
            <div style="color: #00ff88;font-size: 4vw;margin-top: 30px;text-shadow: 0 0 20px #00ff88;">平安喜乐</div>
        </div>
    </div>
    
    <div class="scene" id="scene3">
        <div class="text-container">
            <div class="main-text" style="background: linear-gradient(120deg,#ff00ff,#ffff00,#ff00ff);-webkit-background-clip: text;">万象更新</div>
            <div style="color: #ff00ff;font-size: 4vw;margin-top: 30px;text-shadow: 0 0 20px #ff00ff;">心想事成</div>
        </div>
    </div>
    
    <canvas id="fireworks"></canvas>
    
    <div class="control-panel">
        <button class="control-btn" onclick="launchBeautifulHeart()">发射爱心</button>
        <button class="control-btn" onclick="addFireworks(15)">烟花雨</button>
        <button class="control-btn" onclick="addBlessings()">发送祝福</button>
        <button class="control-btn" onclick="launchPetalRain()">漫天花瓣</button>
    </div>
    
    <div class="fireworks-count">烟花数量: <span id="count">0</span></div>

<script>
const canvas = document.getElementById('fireworks');
const ctx = canvas.getContext('2d');
let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

const particles = [];
const fireworks = [];
const sparks = [];
const petals = [];
const snowflakes = [];
const hearts = [];
const backgroundFireworks = []; // 专门用于背景流线烟花的数组
let mouseX = 0;
let mouseY = 0;

const blessings = ['元旦快乐','岁岁平安','万事顺遂','喜乐安康','前程似锦','阖家幸福','财源广进','心想事成','新年大吉','吉祥如意'];
const colors = ['#ff0000','#ff3333','#ff6600','#ff9900','#ffcc00','#ffff00','#ff0066','#ff3399','#00ff88','#0088ff','#ff00ff'];
const petalColors = ['#ff0066','#ff3399','#ff66cc','#ff99cc','#ffccff','#ff9900','#ffcc00','#ffff00'];

// 改进的花瓣颜色 - 更真实的花瓣颜色
const realisticPetalColors = [
    '#ffb7c5', // 樱花粉
    '#ffccd5', // 浅粉
    '#ff9999', // 桃红
    '#ffcccc', // 淡红
    '#ffd9e6', // 浅玫瑰
    '#ffb3ba', // 珊瑚粉
    '#ffccff', // 淡紫
    '#ffe6ee'  // 极浅粉
];

let currentScene = 0;
const scenes = document.querySelectorAll('.scene');

function resizeCanvas() {
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
}

// ============= 改进的雪花 =============
class Snowflake {
    constructor() {
        this.x = Math.random() * canvasWidth;
        this.y = Math.random() * canvasHeight;
        this.size = Math.random() * 3 + 1;
        this.speedY = Math.random() * 1.5 + 0.5;
        this.speedX = Math.random() * 1 - 0.5;
        this.opacity = Math.random() * 0.5 + 0.5;
        this.wobble = Math.random() * 0.5;
        this.wobbleSpeed = Math.random() * 0.05 + 0.02;
        this.wobbleX = 0;
    }
    update() {
        this.y += this.speedY;
        this.x += this.speedX + Math.sin(this.wobble) * this.wobbleSpeed;
        this.wobble += this.wobbleSpeed;
        this.wobbleX = Math.sin(this.wobble) * 1.5;
        if (this.y > canvasHeight) {
            this.y = 0;
            this.x = Math.random() * canvasWidth;
        }
        if(this.x < 0 || this.x > canvasWidth) this.x = Math.random() * canvasWidth;
    }
    draw() {
        ctx.beginPath();
        ctx.arc(this.x + this.wobbleX, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${this.opacity})`;
        ctx.fill();
    }
}

// ============= 改进的花瓣 - 更像真实花瓣 =============
class RealPetal {
    constructor(x, y, isRain = false) {
        this.x = x || Math.random() * canvasWidth;
        this.y = y || (isRain ? -50 : Math.random() * canvasHeight);
        this.size = Math.random() * 8 + 4; // 更大更明显的花瓣
        this.speedY = isRain ? (Math.random() * 3 + 2) : (Math.random() * 2 + 1);
        this.speedX = Math.random() * 2 - 1;
        this.color = realisticPetalColors[Math.floor(Math.random() * realisticPetalColors.length)];
        this.angle = Math.random() * Math.PI * 2;
        this.rotateSpeed = Math.random() * 0.15 - 0.075;
        this.opacity = Math.random() * 0.4 + 0.6;
        this.swing = Math.random() * 0.5;
        this.swingSpeed = Math.random() * 0.03 + 0.01;
        this.swingDirection = Math.random() > 0.5 ? 1 : -1;
        this.shapeType = Math.floor(Math.random() * 3); // 0: 椭圆, 1: 心形, 2: 水滴
    }
    
    update() {
        this.y += this.speedY;
        this.x += this.speedX + Math.sin(this.swing) * this.swingDirection * 0.8;
        this.swing += this.swingSpeed;
        this.angle += this.rotateSpeed;
        
        // 花瓣飘落时的左右摆动
        if (Math.sin(this.swing) > 0.9) {
            this.swingDirection *= -1;
        }
        
        if (this.y > canvasHeight) {
            this.y = -20;
            this.x = Math.random() * canvasWidth;
        }
        if(this.x < -50) this.x = canvasWidth + 50;
        if(this.x > canvasWidth + 50) this.x = -50;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // 根据形状类型绘制不同形状的花瓣
        if (this.shapeType === 0) {
            // 椭圆形状花瓣
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size/1.8, 0, 0, Math.PI * 2);
        } else if (this.shapeType === 1) {
            // 心形花瓣
            ctx.beginPath();
            ctx.moveTo(0, -this.size/2);
            ctx.bezierCurveTo(this.size/2, -this.size, this.size, 0, 0, this.size);
            ctx.bezierCurveTo(-this.size, 0, -this.size/2, -this.size, 0, -this.size/2);
        } else {
            // 水滴形状花瓣
            ctx.beginPath();
            ctx.ellipse(0, -this.size/4, this.size/1.5, this.size/2, 0, 0, Math.PI * 2);
            ctx.lineTo(0, this.size);
            ctx.closePath();
        }
        
        const rgb = this.hexToRgb(this.color);
        ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${this.opacity})`;
        ctx.fill();
        ctx.restore();
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 255, g: 192, b: 203};
    }
}

// ============= 改进的爱心 =============
class BeautifulHeart {
    constructor(x, y, size = 15) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.speedY = Math.random() * -2 - 3; // 向上飘得更快
        this.speedX = Math.random() * 3 - 1.5;
        this.color = `hsl(${Math.random() * 30 + 330}, 100%, 65%)`; // 粉色系
        this.opacity = 1;
        this.decay = Math.random() * 0.008 + 0.005;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = Math.random() * 0.1 - 0.05;
        this.pulse = 1;
        this.pulseSpeed = 0.05;
    }
    
    update() {
        this.y += this.speedY;
        this.x += this.speedX;
        this.speedY += 0.05; // 重力
        this.speedX *= 0.98; // 空气阻力
        this.opacity -= this.decay;
        this.rotation += this.rotationSpeed;
        this.pulse += this.pulseSpeed;
        if (this.pulse > 1.2 || this.pulse < 0.8) this.pulseSpeed *= -1;
        
        return this.opacity > 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(this.pulse, this.pulse);
        
        // 绘制标准的爱心形状
        ctx.beginPath();
        const size = this.size;
        
        // 使用标准的爱心贝塞尔曲线参数
        ctx.moveTo(0, -size/2);
        // 左半边爱心
        ctx.bezierCurveTo(
            -size, -size,
            -size * 1.2, size/3,
            0, size * 0.8
        );
        // 右半边爱心
        ctx.bezierCurveTo(
            size * 1.2, size/3,
            size, -size,
            0, -size/2
        );
        
        ctx.closePath();
        
        // 渐变填充
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity * 0.8})`);
        gradient.addColorStop(0.5, `rgba(255, 100, 150, ${this.opacity})`);
        gradient.addColorStop(1, `rgba(255, 0, 100, ${this.opacity * 0.7})`);
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // 爱心描边
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.5})`;
        ctx.stroke();
        
        ctx.restore();
    }
}

// ============= 大爱心特效 =============
class BigHeartEffect {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 180;
        this.opacity = 1;
        this.decay = 0.006;
        this.scale = 1;
        this.scaleSpeed = 0.015;
        this.hearts = [];
        this.sparkles = [];
        this.createdAt = Date.now();
    }
    
    update() {
        this.opacity -= this.decay;
        this.scale += this.scaleSpeed;
        
        // 添加小爱心
        if (Date.now() - this.createdAt < 2000 && Math.random() < 0.3) {
            for (let i = 0; i < 3; i++) {
                this.hearts.push({
                    x: this.x + (Math.random() - 0.5) * 100,
                    y: this.y + (Math.random() - 0.5) * 100,
                    size: Math.random() * 10 + 5,
                    speed: Math.random() * 2 + 1,
                    angle: Math.random() * Math.PI * 2,
                    opacity: 0.8
                });
            }
        }
        
        // 更新小爱心
        this.hearts = this.hearts.filter(heart => {
            heart.x += Math.cos(heart.angle) * heart.speed;
            heart.y += Math.sin(heart.angle) * heart.speed;
            heart.opacity -= 0.01;
            return heart.opacity > 0;
        });
        
        return this.opacity > 0;
    }
    
    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        
        // 绘制大爱心
        ctx.beginPath();
        ctx.moveTo(0, -30);
        
        // 更标准的爱心形状
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
            const t = angle;
            // 使用数学公式绘制更标准的爱心
            const sx = 16 * Math.pow(Math.sin(t), 3);
            const sy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            
            const x = sx * 2;
            const y = -sy * 2; // 反转y轴
            
            if (angle === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.closePath();
        
        // 爱心渐变填充
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.3, 'rgba(255, 100, 150, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 0, 100, 0.6)');
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // 爱心发光效果
        ctx.shadowColor = '#ff0066';
        ctx.shadowBlur = 30;
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // 绘制文字
        ctx.fillStyle = 'rgba(255, 210, 230, 0.9)';
        ctx.font = 'bold 36px 微软雅黑';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('2026', 0, -10);
        ctx.font = 'bold 24px 微软雅黑';
        ctx.fillText('新年快乐', 0, 30);
        
        ctx.restore();
        
        // 绘制小爱心
        this.hearts.forEach(heart => {
            ctx.save();
            ctx.globalAlpha = heart.opacity;
            ctx.translate(heart.x, heart.y);
            ctx.rotate(heart.angle);
            
            ctx.beginPath();
            ctx.moveTo(0, -heart.size/2);
            ctx.bezierCurveTo(-heart.size, -heart.size, -heart.size, heart.size/3, 0, heart.size);
            ctx.bezierCurveTo(heart.size, heart.size/3, heart.size, -heart.size, 0, -heart.size/2);
            
            ctx.closePath();
            ctx.fillStyle = `rgba(255, ${100 + Math.random()*155}, 180, ${heart.opacity})`;
            ctx.fill();
            
            ctx.restore();
        });
    }
}

// ============= 背景流线烟花类 =============
class BackgroundFirework {
    constructor() {
        this.x = Math.random() * canvasWidth;
        this.y = canvasHeight + 20;
        this.speedY = Math.random() * -8 - 4; // 向上飞得更快
        this.speedX = Math.random() * 2 - 1;
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.trail = [];
        this.maxTrailLength = 20;
        this.size = Math.random() * 3 + 2;
        this.life = 1;
        this.decay = Math.random() * 0.003 + 0.002;
        this.sparkTimer = 0;
    }
    
    update() {
        // 保存轨迹
        this.trail.push({x: this.x, y: this.y, size: this.size * 0.7});
        if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
        }
        
        this.y += this.speedY;
        this.x += this.speedX;
        this.life -= this.decay;
        
        // 随机发射火花
        this.sparkTimer++;
        if (this.sparkTimer > 5 && this.y < canvasHeight * 0.7) {
            this.sparkTimer = 0;
            for (let i = 0; i < 2; i++) {
                sparks.push(new Spark(this.x, this.y, this.color));
            }
        }
        
        // 当烟花到达顶部或消失时重置
        if (this.y < -20 || this.life <= 0) {
            this.reset();
        }
    }
    
    reset() {
        this.x = Math.random() * canvasWidth;
        this.y = canvasHeight + 20;
        this.speedY = Math.random() * -8 - 4;
        this.speedX = Math.random() * 2 - 1;
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.trail = [];
        this.life = 1;
    }
    
    draw() {
        // 绘制轨迹
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = i / this.trail.length * 0.8;
            
            ctx.beginPath();
            ctx.arc(point.x, point.y, point.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)},${parseInt(this.color.slice(3,5),16)},${parseInt(this.color.slice(5,7),16)},${alpha})`;
            ctx.fill();
        }
        
        // 绘制烟花主体
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)},${parseInt(this.color.slice(3,5),16)},${parseInt(this.color.slice(5,7),16)},${this.life})`;
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x=x;this.y=y;this.speedX=Math.random()*10-5;this.speedY=Math.random()*10-5;this.gravity=0.1;this.friction=0.96;this.color=color||colors[Math.floor(Math.random()*colors.length)];this.size=Math.random()*2+1;this.alpha=1;this.decay=Math.random()*0.015+0.005;
    }
    update() {this.speedX*=this.friction;this.speedY*=this.friction;this.speedY+=this.gravity;this.x+=this.speedX;this.y+=this.speedY;this.alpha-=this.decay;}
    draw() {ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fillStyle=`rgba(${parseInt(this.color.slice(1,3),16)},${parseInt(this.color.slice(3,5),16)},${parseInt(this.color.slice(5,7),16)},${this.alpha})`;ctx.fill();}
}

class Firework {
    constructor(x, y) {
        this.x=x;this.y=y;this.targetX=x;this.targetY=Math.random()*canvasHeight/3+canvasHeight/4;this.speed=Math.random()*6+6;this.angle=Math.atan2(this.targetY-this.y,this.targetX-this.x);this.color=colors[Math.floor(Math.random()*colors.length)];this.size=3;this.exploded=false;
    }
    update() {
        const dx=this.targetX-this.x;const dy=this.targetY-this.y;const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist<this.speed){this.explode();this.exploded=true;}else{this.x+=Math.cos(this.angle)*this.speed;this.y+=Math.sin(this.angle)*this.speed;}
    }
    explode() {
        for(let i=0;i<100;i++)particles.push(new Particle(this.x,this.y,this.color));
        for(let i=0;i<20;i++)hearts.push(new BeautifulHeart(this.x,this.y));
    }
    draw() {ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();}
}

class Spark {
    constructor(x, y, color) {this.x=x;this.y=y;this.speedX=Math.random()*4-2;this.speedY=Math.random()*4-2;this.size=Math.random()*2+1;this.color=color||colors[Math.floor(Math.random()*colors.length)];this.alpha=1;this.decay=Math.random()*0.04+0.01;}
    update() {this.x+=this.speedX;this.y+=this.speedY;this.alpha-=this.decay;}
    draw() {ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fillStyle=`rgba(${parseInt(this.color.slice(1,3),16)},${parseInt(this.color.slice(3,5),16)},${parseInt(this.color.slice(5,7),16)},${this.alpha})`;ctx.fill();}
}

function createBlessing() {
    const blessing=document.createElement('div');
    blessing.className='blessing';
    blessing.textContent=blessings[Math.floor(Math.random()*blessings.length)];
    blessing.style.left=Math.random()*canvasWidth+'px';
    blessing.style.top=canvasHeight+'px';
    blessing.style.fontSize=Math.random()*20+18+'px';
    blessing.style.animation=`float ${Math.random()*7+8}s linear forwards`;
    document.body.appendChild(blessing);
    setTimeout(()=>blessing.remove(),15000);
}

function addBlessings() {for(let i=0;i<5;i++)setTimeout(createBlessing,i*300);}
function addFireworks(count) {for(let i=0;i<count;i++)setTimeout(()=>fireworks.push(new Firework(Math.random()*canvasWidth,canvasHeight)),i*100);}

// 改进的漫天花瓣效果
function launchPetalRain() {
    // 清除现有普通花瓣，只保留真实花瓣
    petals.length = 0;
    for(let i=0;i<300;i++) {
        petals.push(new RealPetal(Math.random()*canvasWidth, -20, true));
    }
}

// 改进的发射爱心效果
function launchBeautifulHeart() {
    hearts.push(new BigHeartEffect(canvasWidth/2, canvasHeight/2));
    for(let i=0;i<100;i++) {
        hearts.push(new BeautifulHeart(canvasWidth/2, canvasHeight/2, Math.random()*10+8));
    }
    for(let i=0;i<200;i++) {
        particles.push(new Particle(canvasWidth/2, canvasHeight/2, '#ff6699'));
    }
}

function init() {
    // 初始化雪花
    for(let i=0;i<80;i++){snowflakes.push(new Snowflake());}
    
    // 初始化背景流线烟花 - 更多更密集
    for(let i=0;i<25;i++){backgroundFireworks.push(new BackgroundFirework());}
    
    // 祝福语间隔
    setInterval(createBlessing,1500);
    
    // 自动发射烟花 - 更多更频繁
    setInterval(()=>{
        if(currentScene===0) {
            // 每次发射2-4个烟花
            for(let i=0;i<Math.floor(Math.random()*3)+2;i++) {
                fireworks.push(new Firework(Math.random()*canvasWidth,canvasHeight));
            }
        }
    },800);
}

function animate() {
    requestAnimationFrame(animate);
    ctx.fillStyle='rgba(0,0,0,0.08)';
    ctx.fillRect(0,0,canvasWidth,canvasHeight);
    
    // 更新和绘制所有效果
    snowflakes.forEach((s,i)=>{s.update();s.draw();});
    
    // 更新和绘制背景流线烟花
    backgroundFireworks.forEach((f,i)=>{f.update();f.draw();});
    
    petals.forEach((p,i)=>{p.update();p.draw();});
    particles.forEach((p,i)=>{p.update();p.draw();if(p.alpha<=0)particles.splice(i,1);});
    fireworks.forEach((f,i)=>{f.update();f.draw();if(f.exploded)fireworks.splice(i,1);});
    sparks.forEach((s,i)=>{s.update();s.draw();if(s.alpha<=0)sparks.splice(i,1);});
    hearts.forEach((h,i)=>{if(h.update) {if(!h.update()) hearts.splice(i,1);} else {if(h.opacity<=0) hearts.splice(i,1);}});
    hearts.forEach(h=>h.draw());
    
    // 统计数量
    const totalCount = fireworks.length + particles.length + hearts.length + backgroundFireworks.length;
    document.getElementById('count').textContent = totalCount;
}

canvas.addEventListener('click', (e) => {
    fireworks.push(new Firework(e.clientX,e.clientY));
    for(let i=0;i<15;i++)particles.push(new Particle(e.clientX,e.clientY));
    for(let i=0;i<10;i++)hearts.push(new BeautifulHeart(e.clientX,e.clientY));
});

canvas.addEventListener('mousemove', (e) => {
    mouseX=e.clientX;mouseY=e.clientY;
    if(Math.random()>0.5)sparks.push(new Spark(e.clientX,e.clientY));
});

window.addEventListener('resize', resizeCanvas);
init();animate();
</script>
</body>
  </html>
